/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  LIRPSuggestModal: () => LIRPSuggestModal,
  default: () => ListItemRandomPicker
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
function findIndexes(anArray, predicate) {
  const indexes = [];
  anArray.forEach((element, index) => {
    if (predicate(element, index)) {
      indexes.push(index);
    }
  });
  return indexes;
}
var DEFAULT_SETTINGS = {
  notePath: "Full path of a note",
  showWarning: true,
  maxMacroDepth: 1,
  noticePrefix: "!"
};
var LIRPList = class {
  constructor(lines) {
    this.title = "";
    this.description = "";
    this.hidden = false;
    this.items = [];
    this.warning = [];
    const headingRegEx = /^# +(.+)$/;
    this.title = lines[0].replace(headingRegEx, "$1");
    const italicHeadingRegex = /^(_|\*)\S/;
    if (italicHeadingRegex.test(this.title)) {
      this.hidden = true;
    } else {
      this.hidden = false;
    }
    lines.shift();
    const listBeginItemRegex = /^(-|\d+\.) +(.+)$/;
    const listBeginIndexes = findIndexes(lines, (element) => listBeginItemRegex.test(element));
    if (listBeginIndexes.length === 0) {
      this.warning.push(`No items in list ${this.title}`);
      this.hidden = true;
      return;
    }
    const cleanLines = lines.map((element) => {
      return element.replace(listBeginItemRegex, "$2");
    });
    if (listBeginIndexes[0] !== 0) {
      let mdDescription = cleanLines.slice(0, listBeginIndexes[0]);
      if (mdDescription[0] === "") {
        mdDescription.shift();
      }
      this.description = mdDescription.join("\n");
    } else {
      this.description = "";
    }
    const listBeginCount = listBeginIndexes.length;
    let item;
    for (let currentIndex = 0; currentIndex < listBeginCount - 1; currentIndex++) {
      item = cleanLines.slice(listBeginIndexes[currentIndex], listBeginIndexes[currentIndex + 1]);
      this.pushItemBasedOnWeight(item);
    }
    item = cleanLines.slice(listBeginIndexes[listBeginCount - 1]);
    if (item.at(-1) === "") {
      item.pop();
    }
    this.pushItemBasedOnWeight(item);
  }
  pushItemBasedOnWeight(item) {
    const ItemWithWeightRegEx = /^\((\d+)\)\s+(.+)$/;
    let regExExecution;
    let repeat;
    if ((regExExecution = ItemWithWeightRegEx.exec(item[0])) !== null) {
      repeat = Number(regExExecution[1]);
      item[0] = regExExecution[2];
    } else {
      repeat = 1;
    }
    const stringItem = item.join("\n");
    for (let i = 0; i < repeat; i++) {
      this.items.push(stringItem);
    }
  }
  getListSuggestion() {
    const suggestion = {
      title: this.title,
      description: this.description.split("\n")[0]
    };
    return suggestion;
  }
  notHidden() {
    return !this.hidden;
  }
  pickRandomItem() {
    let randomItem = "";
    if (this.items.length > 0) {
      randomItem = this.items[Math.floor(Math.random() * this.items.length)];
    }
    return randomItem;
  }
  getWarning() {
    return this.warning;
  }
};
var LIRPNote = class {
  constructor() {
    this.noteName = "";
    this.description = "";
    this.list = [];
    this.error = [];
    this.warning = [];
  }
  loadFromNote(noteName, noteContent) {
    this.noteName = noteName;
    const lines = noteContent.split("\n");
    const headingRegex = /^# .+$/;
    let headingIndexes = findIndexes(lines, (element) => headingRegex.test(element));
    if (headingIndexes.length === 0) {
      this.error.push(`No heading in note`);
      return false;
    }
    if (headingIndexes[0] !== 0) {
      this.description = lines.slice(0, headingIndexes[0]).join("\n");
    }
    const headingCount = headingIndexes.length;
    for (let currentIndex = 0; currentIndex < headingCount - 1; currentIndex++) {
      this.list.push(new LIRPList(lines.slice(headingIndexes[currentIndex], headingIndexes[currentIndex + 1])));
    }
    this.list.push(new LIRPList(lines.slice(headingIndexes[headingCount - 1])));
    return true;
  }
  getNoteSuggestion() {
    let noteSuggestion;
    noteSuggestion = [];
    this.list.forEach((element) => {
      if (element.notHidden()) {
        noteSuggestion.push(element.getListSuggestion());
      }
    });
    return noteSuggestion;
  }
  execMacroSubstitution(item, macroRecursion) {
    const stringMacroRefRegex = `{(${this.list.map((element) => element.title).join("|")})}`;
    const macroRefRegex = new RegExp(stringMacroRefRegex, "mg");
    let match;
    let modifiedItem = item;
    let listTitle = "";
    while ((match = macroRefRegex.exec(modifiedItem)) !== null) {
      let newValue = this.pickRandomItemFromList(match[1], -1);
      listTitle = match[0];
      modifiedItem = modifiedItem.replace(listTitle, newValue);
      macroRefRegex.lastIndex = match.index + newValue.length;
    }
    return {
      lastListTitle: listTitle,
      modifiedItem
    };
  }
  pickRandomItemFromList(listTitle, macroRecursion) {
    let randomItem = "";
    let returnOfExecMacro = {
      lastListTitle: "",
      modifiedItem: ""
    };
    const currentList = this.list.find((element) => element.title === listTitle);
    if (currentList !== void 0) {
      randomItem = currentList.pickRandomItem();
      for (let repeat = 0; repeat < macroRecursion; repeat++) {
        returnOfExecMacro = this.execMacroSubstitution(randomItem, macroRecursion);
        randomItem = returnOfExecMacro.modifiedItem;
      }
    }
    const stringMacroRefRegex = `{(${this.list.map((element) => element.title).join("|")})}`;
    const macroRefRegex = new RegExp(stringMacroRefRegex);
    if (macroRefRegex.test(randomItem) && macroRecursion !== -1) {
      new import_obsidian.Notice(`Macro depth limit reached in note "${this.noteName}" after calling "${returnOfExecMacro.lastListTitle}"`);
    }
    ;
    return randomItem;
  }
  getError() {
    return this.error;
  }
  getWarning() {
    let allWarning;
    allWarning = [];
    allWarning = allWarning.concat(this.warning);
    this.list.forEach((element) => {
      allWarning = allWarning.concat(element.getWarning());
    });
    let NoteWarning;
    NoteWarning = [];
    allWarning.forEach(
      (element) => NoteWarning.push(`Warning in note "${this.noteName}" : ${element}`)
    );
    return NoteWarning;
  }
};
var LIRPSuggestModal = class extends import_obsidian.SuggestModal {
  constructor(app, items, callback) {
    super(app);
    this.items = items;
    this.callback = callback;
  }
  getSuggestions(query) {
    return this.items.filter(
      (item) => item.title.toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.title });
    el.createEl("small", { text: item.description });
  }
  onChooseSuggestion(item, evt) {
    this.callback(item.title);
  }
};
var ListItemRandomPicker = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("list-tree", "Pick random list item", (evt) => {
      this.doTheJob(this.settings.notePath + ".md");
    });
    this.addCommand({
      id: "insert-random-item",
      name: "Insert random item from list",
      callback: () => {
        this.doTheJob(this.settings.notePath + ".md");
      }
    });
    this.addSettingTab(new LIRPSettingTab(this.app, this));
  }
  onunload() {
  }
  async doTheJob(fullNotePath) {
    const file = this.app.vault.getAbstractFileByPath(fullNotePath);
    if (!file) {
      new import_obsidian.Notice("Note not found!");
      return;
    }
    if (!(file instanceof import_obsidian.TFile)) {
      new import_obsidian.Notice("Invalid file type. Expected a Markdown note file.");
      return;
    }
    const content = await this.app.vault.cachedRead(file);
    const currentLIRP = new LIRPNote();
    const loadSuccess = currentLIRP.loadFromNote(this.settings.notePath, content);
    if (!loadSuccess) {
      currentLIRP.getError().forEach((element) => new import_obsidian.Notice(element));
      return;
    }
    if (this.settings.showWarning) {
      currentLIRP.getWarning().forEach((element) => {
        new import_obsidian.Notice(element);
      });
    }
    ;
    new LIRPSuggestModal(this.app, currentLIRP.getNoteSuggestion(), (title) => {
      this.workWithString(title, currentLIRP.pickRandomItemFromList(title, this.settings.maxMacroDepth));
    }).open();
  }
  workWithString(listTitle, stringToWorkWith) {
    const stringNoticeRegex = `^ *${this.settings.noticePrefix}(.*)`;
    const noticeRegex = new RegExp(stringNoticeRegex);
    if (noticeRegex.test(listTitle)) {
      new import_obsidian.Notice(stringToWorkWith);
    } else {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView) {
        const editor = activeView.editor;
        const selection = editor.getSelection();
        editor.replaceSelection(stringToWorkWith);
      } else {
        new import_obsidian.Notice("No active Markdown editor found.");
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var LIRPSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Note Path").setDesc('The path and filename of the note that contains the lists to be used. Exemple : "Folder/Note".').addText(
      (text) => text.setPlaceholder("Enter the path to your note").setValue(this.plugin.settings.notePath).onChange(async (value) => {
        this.plugin.settings.notePath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show warning").setDesc("Display the warnings of notes and lists, if any. Warnings for macro depth limit reached are always displayed.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showWarning);
      toggle.onChange(async (value) => {
        this.plugin.settings.showWarning = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Macro depth limit").setDesc("Macro recursion limit: how many nested macro calls are allowed. Zero prevents nested macros from being resolved.").addSlider(
      (slider) => slider.setValue(this.plugin.settings.maxMacroDepth - 1).setLimits(0, 10, 1).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxMacroDepth = value + 1;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("List prefix for notification").setDesc("If a list heading begin with the specified value, the picked item is not inserted, but notified.").addText(
      (text) => text.setPlaceholder("Enter prefix value").setValue(this.plugin.settings.noticePrefix).onChange(async (value) => {
        this.plugin.settings.noticePrefix = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBTdWdnZXN0TW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBURmlsZSwgTWFya2Rvd25WaWV3IH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5mdW5jdGlvbiBmaW5kSW5kZXhlczxUPihhbkFycmF5OiBUW10sIHByZWRpY2F0ZTogKGVsZW1lbnQ6IFQsIGluZGV4OiBudW1iZXIpID0+IGJvb2xlYW4pOiBudW1iZXJbXSB7XG4gICAgY29uc3QgaW5kZXhlczogbnVtYmVyW10gPSBbXTtcbiAgICBhbkFycmF5LmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQsIGluZGV4KSkge1xuICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpbmRleGVzO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHJpbmdUb0VzY2FwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3RyaW5nVG9Fc2NhcGUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn1cbmludGVyZmFjZSBMSVJQUGx1Z2luU2V0dGluZ3Mge1xuICAgIG5vdGVQYXRoOiBzdHJpbmc7XG4gICAgc2hvd1dhcm5pbmc6IGJvb2xlYW47XG4gICAgbWF4TWFjcm9EZXB0aDogbnVtYmVyO1xuICAgIG5vdGljZVByZWZpeDogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBMSVJQUGx1Z2luU2V0dGluZ3MgPSB7XG4gICAgbm90ZVBhdGg6ICdGdWxsIHBhdGggb2YgYSBub3RlJyxcbiAgICBzaG93V2FybmluZzogdHJ1ZSxcbiAgICBtYXhNYWNyb0RlcHRoOiAxLFxuICAgIG5vdGljZVByZWZpeDogJyEnLFxufTtcblxuaW50ZXJmYWNlIExJUlBMaXN0SW50ZXJmYWNlIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgaXRlbXM6IHN0cmluZ1tdO1xuICAgIGdldExpc3RTdWdnZXN0aW9uKCk6IExJUlBTdWdnZXN0aW9uSW50ZXJmYWNlO1xuICAgIG5vdEhpZGRlbigpOiBib29sZWFuO1xuICAgIHBpY2tSYW5kb21JdGVtKCk6IHN0cmluZztcbiAgICBnZXRXYXJuaW5nKCk6IHN0cmluZ1tdO1xufVxuXG5jbGFzcyBMSVJQTGlzdCBpbXBsZW1lbnRzIExJUlBMaXN0SW50ZXJmYWNlIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgaGlkZGVuOiBib29sZWFuO1xuICAgIGl0ZW1zOiBzdHJpbmdbXTtcbiAgICB3YXJuaW5nOiBzdHJpbmdbXVxuXG4gICAgY29uc3RydWN0b3IobGluZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmcgPSBbXTtcblxuICAgICAgICBjb25zdCBoZWFkaW5nUmVnRXggPSAvXiMgKyguKykkLztcbiAgICAgICAgdGhpcy50aXRsZSA9IGxpbmVzWzBdLnJlcGxhY2UoaGVhZGluZ1JlZ0V4LCBcIiQxXCIpO1xuICAgICAgICBjb25zdCBpdGFsaWNIZWFkaW5nUmVnZXggPSAvXihffFxcKilcXFMvO1xuICAgICAgICBpZiAoaXRhbGljSGVhZGluZ1JlZ2V4LnRlc3QodGhpcy50aXRsZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMuc2hpZnQoKTtcbiAgICAgICAgY29uc3QgbGlzdEJlZ2luSXRlbVJlZ2V4ID0gL14oLXxcXGQrXFwuKSArKC4rKSQvO1xuICAgICAgICBjb25zdCBsaXN0QmVnaW5JbmRleGVzID0gZmluZEluZGV4ZXMobGluZXMsIChlbGVtZW50KSA9PiBsaXN0QmVnaW5JdGVtUmVnZXgudGVzdChlbGVtZW50KSk7XG4gICAgICAgIGlmIChsaXN0QmVnaW5JbmRleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy53YXJuaW5nLnB1c2goYE5vIGl0ZW1zIGluIGxpc3QgJHt0aGlzLnRpdGxlfWApO1xuICAgICAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsZWFuTGluZXMgPSBsaW5lcy5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnJlcGxhY2UobGlzdEJlZ2luSXRlbVJlZ2V4LCBcIiQyXCIpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGlzdEJlZ2luSW5kZXhlc1swXSAhPT0gMCkge1xuICAgICAgICAgICAgbGV0IG1kRGVzY3JpcHRpb24gPSBjbGVhbkxpbmVzLnNsaWNlKDAsIGxpc3RCZWdpbkluZGV4ZXNbMF0pO1xuICAgICAgICAgICAgLy8gdGFraW5nIGNhcmUgb2YgTUQwMjJcbiAgICAgICAgICAgIC8vICAgTUQwMjIvYmxhbmtzLWFyb3VuZC1oZWFkaW5nczogSGVhZGluZ3Mgc2hvdWxkIGJlIHN1cnJvdW5kZWQgYnkgYmxhbmsgbGluZXNcbiAgICAgICAgICAgIGlmIChtZERlc2NyaXB0aW9uWzBdID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgbWREZXNjcmlwdGlvbi5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGFraW5nIGNhcmUgb2YgTUQwMzJcbiAgICAgICAgICAgIC8vICAgTUQwMzIvYmxhbmtzLWFyb3VuZC1saXN0czogTGlzdHMgc2hvdWxkIGJlIHN1cnJvdW5kZWQgYnkgYmxhbmsgbGluZXNcbiAgICAgICAgICAgIC8vIER1ZSB0byBzcGxpdCBvbiAnXFxuJywgdGhlIHNsaWNlLCBhbmQgYXQgbGVhc3QgYSBqb2luIG9uICdcXG4nIHRoZSBsYXN0ICdcXG4nIGlzIGFsd2F5cyBsb3N0ICFcbiAgICAgICAgICAgIC8vIFNvIHRoZSBmb2xvd2luZyBjb2RlIGlzIHVzZWxlc3NcbiAgICAgICAgICAgIC8vIGlmIChtZERlc2NyaXB0aW9uLmF0KC0xKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgLy8gICAgIG1kRGVzY3JpcHRpb24ucG9wKCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gbWREZXNjcmlwdGlvbi5qb2luKCdcXG4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdEJlZ2luQ291bnQgPSBsaXN0QmVnaW5JbmRleGVzLmxlbmd0aFxuICAgICAgICBsZXQgaXRlbTogc3RyaW5nW107XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnRJbmRleCA9IDA7IGN1cnJlbnRJbmRleCA8IChsaXN0QmVnaW5Db3VudCAtIDEpOyBjdXJyZW50SW5kZXgrKykge1xuICAgICAgICAgICAgaXRlbSA9IChjbGVhbkxpbmVzLnNsaWNlKGxpc3RCZWdpbkluZGV4ZXNbY3VycmVudEluZGV4XSwgbGlzdEJlZ2luSW5kZXhlc1tjdXJyZW50SW5kZXggKyAxXSkpO1xuICAgICAgICAgICAgdGhpcy5wdXNoSXRlbUJhc2VkT25XZWlnaHQoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbSA9IChjbGVhbkxpbmVzLnNsaWNlKGxpc3RCZWdpbkluZGV4ZXNbbGlzdEJlZ2luQ291bnQgLSAxXSkpO1xuICAgICAgICAvLyB0YWtpbmcgY2FyZSBvZiBNRDAyMlxuICAgICAgICAvLyAgIE1EMDIyL2JsYW5rcy1hcm91bmQtaGVhZGluZ3M6IEhlYWRpbmdzIHNob3VsZCBiZSBzdXJyb3VuZGVkIGJ5IGJsYW5rIGxpbmVzXG4gICAgICAgIGlmIChpdGVtLmF0KC0xKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgaXRlbS5wb3AoKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgICAgIHRoaXMucHVzaEl0ZW1CYXNlZE9uV2VpZ2h0KGl0ZW0pO1xuICAgIH1cblxuICAgIHB1c2hJdGVtQmFzZWRPbldlaWdodChpdGVtOiBzdHJpbmdbXSkgOiB2b2lkIHtcbiAgICAgICAgY29uc3QgSXRlbVdpdGhXZWlnaHRSZWdFeCA9IC9eXFwoKFxcZCspXFwpXFxzKyguKykkLztcbiAgICAgICAgbGV0IHJlZ0V4RXhlY3V0aW9uXG4gICAgICAgIGxldCByZXBlYXQ6IG51bWJlcjtcbiAgICAgICAgaWYgKChyZWdFeEV4ZWN1dGlvbiA9IEl0ZW1XaXRoV2VpZ2h0UmVnRXguZXhlYyhpdGVtWzBdKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlcGVhdCA9IE51bWJlcihyZWdFeEV4ZWN1dGlvblsxXSk7XG4gICAgICAgICAgICBpdGVtWzBdID0gcmVnRXhFeGVjdXRpb25bMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBlYXQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmluZ0l0ZW0gPSBpdGVtLmpvaW4oJ1xcbicpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcGVhdDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goc3RyaW5nSXRlbSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0TGlzdFN1Z2dlc3Rpb24oKTogTElSUFN1Z2dlc3Rpb25JbnRlcmZhY2Uge1xuICAgICAgICBjb25zdCBzdWdnZXN0aW9uID0ge1xuICAgICAgICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogKHRoaXMuZGVzY3JpcHRpb24uc3BsaXQoJ1xcbicpWzBdKSxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VnZ2VzdGlvbjtcbiAgICB9O1xuXG4gICAgbm90SGlkZGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGlkZGVuO1xuICAgIH1cblxuICAgIHBpY2tSYW5kb21JdGVtKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCByYW5kb21JdGVtOiBzdHJpbmcgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByYW5kb21JdGVtID0gdGhpcy5pdGVtc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLml0ZW1zLmxlbmd0aCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5kb21JdGVtO1xuICAgIH1cblxuICAgIGdldFdhcm5pbmcoKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy53YXJuaW5nO1xuICAgIH1cblxufVxuXG5pbnRlcmZhY2UgTElSUEV4ZWNNYWNyb0ludGVyZmFjZSB7XG4gICAgbGFzdExpc3RUaXRsZTogc3RyaW5nO1xuICAgIG1vZGlmaWVkSXRlbTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTElSUE5vdGVJbnRlcmZhY2Uge1xuICAgIG5vdGVOYW1lOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICBsb2FkRnJvbU5vdGUobm90ZU5hbWU6IHN0cmluZywgbm90ZUNvbnRlbnQ6IHN0cmluZyk6IGJvb2xlYW47XG4gICAgZ2V0Tm90ZVN1Z2dlc3Rpb24oKTogTElSUFN1Z2dlc3Rpb25JbnRlcmZhY2VbXTtcbiAgICBwaWNrUmFuZG9tSXRlbUZyb21MaXN0KGxpc3RUaXRsZTogc3RyaW5nLCBtYWNyb1JlY3Vyc2lvbjogbnVtYmVyKTogc3RyaW5nOyBcbiAgICBnZXRFcnJvcigpOiBzdHJpbmdbXTtcbiAgICBnZXRXYXJuaW5nKCk6IHN0cmluZ1tdO1xufVxuXG5jbGFzcyBMSVJQTm90ZSBpbXBsZW1lbnRzIExJUlBOb3RlSW50ZXJmYWNlIHtcbiAgICBub3RlTmFtZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgbGlzdDogTElSUExpc3RbXTtcbiAgICBlcnJvcjogc3RyaW5nW107XG4gICAgd2FybmluZzogc3RyaW5nW107XG5cbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHRoaXMubm90ZU5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICAgICAgdGhpcy5saXN0ID0gW107XG4gICAgICAgIHRoaXMuZXJyb3IgPSBbXTtcbiAgICAgICAgdGhpcy53YXJuaW5nID0gW107XG4gICAgfVxuXG4gICAgbG9hZEZyb21Ob3RlKG5vdGVOYW1lOiBzdHJpbmcsIG5vdGVDb250ZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgdGhpcy5ub3RlTmFtZSA9IG5vdGVOYW1lO1xuICAgICAgICBjb25zdCBsaW5lcyA9IG5vdGVDb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3QgaGVhZGluZ1JlZ2V4ID0gL14jIC4rJC87XG4gICAgICAgIGxldCBoZWFkaW5nSW5kZXhlcyA9IGZpbmRJbmRleGVzKGxpbmVzLCAoZWxlbWVudCkgPT4gaGVhZGluZ1JlZ2V4LnRlc3QoZWxlbWVudCkpO1xuICAgICAgICBpZiAoaGVhZGluZ0luZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yLnB1c2goYE5vIGhlYWRpbmcgaW4gbm90ZWApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkaW5nSW5kZXhlc1swXSAhPT0gMCkge1xuICAgICAgICAgICAgLy8gdGFraW5nIGNhcmUgb2YgTUQwMjJcbiAgICAgICAgICAgIC8vICAgTUQwMjIvYmxhbmtzLWFyb3VuZC1oZWFkaW5nczogSGVhZGluZ3Mgc2hvdWxkIGJlIHN1cnJvdW5kZWQgYnkgYmxhbmsgbGluZXNcbiAgICAgICAgICAgIC8vIER1ZSB0byBzcGxpdCBvbiAnXFxuJywgdGhlIHNsaWNlLCBhbmQgYXQgbGVhc3QgYSBqb2luIG9uICdcXG4nIHRoZSBsYXN0ICdcXG4nIGlzIGFsd2F5cyBsb3N0ICFcbiAgICAgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBsaW5lcy5zbGljZSgwLCBoZWFkaW5nSW5kZXhlc1swXSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGluZ0NvdW50ID0gaGVhZGluZ0luZGV4ZXMubGVuZ3RoXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnRJbmRleCA9IDA7IGN1cnJlbnRJbmRleCA8IChoZWFkaW5nQ291bnQgLSAxKTsgY3VycmVudEluZGV4KyspIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5wdXNoKG5ldyBMSVJQTGlzdChsaW5lcy5zbGljZShoZWFkaW5nSW5kZXhlc1tjdXJyZW50SW5kZXhdLCBoZWFkaW5nSW5kZXhlc1tjdXJyZW50SW5kZXggKyAxXSkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3QucHVzaChuZXcgTElSUExpc3QobGluZXMuc2xpY2UoaGVhZGluZ0luZGV4ZXNbaGVhZGluZ0NvdW50IC0gMV0pKSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgZ2V0Tm90ZVN1Z2dlc3Rpb24oKTogTElSUFN1Z2dlc3Rpb25JbnRlcmZhY2VbXSB7XG4gICAgICAgIGxldCBub3RlU3VnZ2VzdGlvbjogTElSUFN1Z2dlc3Rpb25JbnRlcmZhY2VbXTtcbiAgICAgICAgbm90ZVN1Z2dlc3Rpb24gPSBbXTtcbiAgICAgICAgdGhpcy5saXN0LmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vdEhpZGRlbigpKSB7XG4gICAgICAgICAgICAgICAgbm90ZVN1Z2dlc3Rpb24ucHVzaChlbGVtZW50LmdldExpc3RTdWdnZXN0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vdGVTdWdnZXN0aW9uO1xuICAgIH1cblxuICAgIGV4ZWNNYWNyb1N1YnN0aXR1dGlvbihpdGVtOiBzdHJpbmcsIG1hY3JvUmVjdXJzaW9uOiBudW1iZXIpOiBMSVJQRXhlY01hY3JvSW50ZXJmYWNlIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nTWFjcm9SZWZSZWdleDogc3RyaW5nID0gYFxceygke3RoaXMubGlzdC5tYXAoKGVsZW1lbnQpID0+IGVsZW1lbnQudGl0bGUpLmpvaW4oJ3wnKX0pXFx9YDtcbiAgICAgICAgY29uc3QgbWFjcm9SZWZSZWdleCA9IG5ldyBSZWdFeHAgKHN0cmluZ01hY3JvUmVmUmVnZXgsJ21nJyk7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgbGV0IG1vZGlmaWVkSXRlbTpzdHJpbmcgPSBpdGVtO1xuICAgICAgICBsZXQgbGlzdFRpdGxlOnN0cmluZyA9IFwiXCI7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBtYWNyb1JlZlJlZ2V4LmV4ZWMobW9kaWZpZWRJdGVtKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZTogc3RyaW5nID0gdGhpcy5waWNrUmFuZG9tSXRlbUZyb21MaXN0KG1hdGNoWzFdLCAtMSk7IFxuICAgICAgICAgICAgbGlzdFRpdGxlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICBtb2RpZmllZEl0ZW0gPSBtb2RpZmllZEl0ZW0ucmVwbGFjZShsaXN0VGl0bGUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIG1hY3JvUmVmUmVnZXgubGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBuZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhc3RMaXN0VGl0bGU6IGxpc3RUaXRsZSxcbiAgICAgICAgICAgIG1vZGlmaWVkSXRlbTogbW9kaWZpZWRJdGVtLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBpY2tSYW5kb21JdGVtRnJvbUxpc3QobGlzdFRpdGxlOiBzdHJpbmcsIG1hY3JvUmVjdXJzaW9uOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmFuZG9tSXRlbTogc3RyaW5nID0gXCJcIjtcbiAgICAgICAgbGV0IHJldHVybk9mRXhlY01hY3JvOiBMSVJQRXhlY01hY3JvSW50ZXJmYWNlID0ge1xuICAgICAgICAgICAgbGFzdExpc3RUaXRsZTogXCJcIixcbiAgICAgICAgICAgIG1vZGlmaWVkSXRlbTogXCJcIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3VycmVudExpc3QgPSB0aGlzLmxpc3QuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudC50aXRsZSA9PT0gbGlzdFRpdGxlKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJhbmRvbUl0ZW0gPSBjdXJyZW50TGlzdC5waWNrUmFuZG9tSXRlbSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgcmVwZWF0ID0gMDsgcmVwZWF0IDwgbWFjcm9SZWN1cnNpb247IHJlcGVhdCsrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuT2ZFeGVjTWFjcm8gPSB0aGlzLmV4ZWNNYWNyb1N1YnN0aXR1dGlvbihyYW5kb21JdGVtLCBtYWNyb1JlY3Vyc2lvbik7XG4gICAgICAgICAgICAgICAgcmFuZG9tSXRlbSA9IHJldHVybk9mRXhlY01hY3JvLm1vZGlmaWVkSXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmdNYWNyb1JlZlJlZ2V4OiBzdHJpbmcgPSBgXFx7KCR7dGhpcy5saXN0Lm1hcCgoZWxlbWVudCkgPT4gZWxlbWVudC50aXRsZSkuam9pbignfCcpfSlcXH1gO1xuICAgICAgICBjb25zdCBtYWNyb1JlZlJlZ2V4ID0gbmV3IFJlZ0V4cCAoc3RyaW5nTWFjcm9SZWZSZWdleCk7XG4gICAgICAgIGlmIChtYWNyb1JlZlJlZ2V4LnRlc3QocmFuZG9tSXRlbSkgJiYgbWFjcm9SZWN1cnNpb24gIT09IC0xKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBNYWNybyBkZXB0aCBsaW1pdCByZWFjaGVkIGluIG5vdGUgXCIke3RoaXMubm90ZU5hbWV9XCIgYWZ0ZXIgY2FsbGluZyBcIiR7cmV0dXJuT2ZFeGVjTWFjcm8ubGFzdExpc3RUaXRsZX1cImApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmFuZG9tSXRlbTtcbiAgICB9IFxuXG4gICAgZ2V0RXJyb3IoKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcjtcbiAgICB9O1xuXG4gICAgZ2V0V2FybmluZygpOiBzdHJpbmdbXSB7XG4gICAgICAgIGxldCBhbGxXYXJuaW5nOiBzdHJpbmdbXTtcbiAgICAgICAgYWxsV2FybmluZyA9IFtdO1xuICAgICAgICBhbGxXYXJuaW5nID0gYWxsV2FybmluZy5jb25jYXQodGhpcy53YXJuaW5nKTtcbiAgICAgICAgdGhpcy5saXN0LmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGFsbFdhcm5pbmcgPSBhbGxXYXJuaW5nLmNvbmNhdChlbGVtZW50LmdldFdhcm5pbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgTm90ZVdhcm5pbmc6IHN0cmluZ1tdO1xuICAgICAgICBOb3RlV2FybmluZyA9IFtdO1xuICAgICAgICBhbGxXYXJuaW5nLmZvckVhY2goKGVsZW1lbnQpID0+IFxuICAgICAgICAgICAgTm90ZVdhcm5pbmcucHVzaChgV2FybmluZyBpbiBub3RlIFwiJHt0aGlzLm5vdGVOYW1lfVwiIDogJHtlbGVtZW50fWApXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBOb3RlV2FybmluZztcbiAgICB9O1xuXG59XG5pbnRlcmZhY2UgTElSUFN1Z2dlc3Rpb25JbnRlcmZhY2Uge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuXG5leHBvcnQgY2xhc3MgTElSUFN1Z2dlc3RNb2RhbCBleHRlbmRzIFN1Z2dlc3RNb2RhbDxMSVJQU3VnZ2VzdGlvbkludGVyZmFjZT4ge1xuICAgIGl0ZW1zOiBMSVJQU3VnZ2VzdGlvbkludGVyZmFjZVtdO1xuICAgIGNhbGxiYWNrOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZDtcbiAgXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGl0ZW1zOiBMSVJQU3VnZ2VzdGlvbkludGVyZmFjZVtdLCBjYWxsYmFjazogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICAgIHN1cGVyKGFwcCk7XG4gICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZ2V0U3VnZ2VzdGlvbnMocXVlcnk6IHN0cmluZyk6IExJUlBTdWdnZXN0aW9uSW50ZXJmYWNlW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoKGl0ZW0pID0+XG4gICAgICAgICAgICBpdGVtLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBcbiAgICByZW5kZXJTdWdnZXN0aW9uKGl0ZW06IExJUlBTdWdnZXN0aW9uSW50ZXJmYWNlLCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgZWwuY3JlYXRlRWwoJ2RpdicsIHsgdGV4dDogaXRlbS50aXRsZSB9KTtcbiAgICAgICAgZWwuY3JlYXRlRWwoJ3NtYWxsJywge3RleHQ6IGl0ZW0uZGVzY3JpcHRpb259KTtcbiAgICAgIH1cbiAgXG4gICAgICBvbkNob29zZVN1Z2dlc3Rpb24oaXRlbTogTElSUFN1Z2dlc3Rpb25JbnRlcmZhY2UsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhpdGVtLnRpdGxlKTtcbiAgICAgIH19XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RJdGVtUmFuZG9tUGlja2VyIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogTElSUFBsdWdpblNldHRpbmdzO1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbignbGlzdC10cmVlJywgJ1BpY2sgcmFuZG9tIGxpc3QgaXRlbScsIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9UaGVKb2IodGhpcy5zZXR0aW5ncy5ub3RlUGF0aCArICcubWQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnaW5zZXJ0LXJhbmRvbS1pdGVtJyxcbiAgICAgICAgICAgIG5hbWU6ICdJbnNlcnQgcmFuZG9tIGl0ZW0gZnJvbSBsaXN0JyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb1RoZUpvYih0aGlzLnNldHRpbmdzLm5vdGVQYXRoICsgJy5tZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IExJUlBTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG5cbiAgICB9XG5cbiAgICBhc3luYyBkb1RoZUpvYihmdWxsTm90ZVBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZ1bGxOb3RlUGF0aCk7XG5cbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdOb3RlIG5vdCBmb3VuZCEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0ludmFsaWQgZmlsZSB0eXBlLiBFeHBlY3RlZCBhIE1hcmtkb3duIG5vdGUgZmlsZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xuICAgICAgICBjb25zdCBjdXJyZW50TElSUCA9IG5ldyBMSVJQTm90ZSgpO1xuXG4gICAgICAgIGNvbnN0IGxvYWRTdWNjZXNzID0gY3VycmVudExJUlAubG9hZEZyb21Ob3RlKHRoaXMuc2V0dGluZ3Mubm90ZVBhdGgsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoIWxvYWRTdWNjZXNzKSB7XG4gICAgICAgICAgICBjdXJyZW50TElSUC5nZXRFcnJvcigpLmZvckVhY2goKGVsZW1lbnQpID0+IG5ldyBOb3RpY2UoZWxlbWVudCkpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd1dhcm5pbmcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMSVJQLmdldFdhcm5pbmcoKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoZWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgbmV3IExJUlBTdWdnZXN0TW9kYWwodGhpcy5hcHAsIGN1cnJlbnRMSVJQLmdldE5vdGVTdWdnZXN0aW9uKCksICh0aXRsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy53b3JrV2l0aFN0cmluZyh0aXRsZSwgY3VycmVudExJUlAucGlja1JhbmRvbUl0ZW1Gcm9tTGlzdCh0aXRsZSwgdGhpcy5zZXR0aW5ncy5tYXhNYWNyb0RlcHRoKSk7XG4gICAgICAgIH0pLm9wZW4oKTtcbiAgICB9XG5cbiAgICB3b3JrV2l0aFN0cmluZyhsaXN0VGl0bGU6IHN0cmluZywgc3RyaW5nVG9Xb3JrV2l0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0cmluZ05vdGljZVJlZ2V4OnN0cmluZyA9IGBeICoke3RoaXMuc2V0dGluZ3Mubm90aWNlUHJlZml4fSguKilgO1xuICAgICAgICBjb25zdCBub3RpY2VSZWdleCA9IG5ldyBSZWdFeHAoc3RyaW5nTm90aWNlUmVnZXgpO1xuXG4gICAgICAgIGlmIChub3RpY2VSZWdleC50ZXN0KGxpc3RUaXRsZSkpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2Uoc3RyaW5nVG9Xb3JrV2l0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcblxuICAgICAgICAgICAgaWYgKGFjdGl2ZVZpZXcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVWaWV3LmVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oc3RyaW5nVG9Xb3JrV2l0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBhY3RpdmUgTWFya2Rvd24gZWRpdG9yIGZvdW5kLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG59XG5cbmNsYXNzIExJUlBTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgcGx1Z2luOiBMaXN0SXRlbVJhbmRvbVBpY2tlcjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IExpc3RJdGVtUmFuZG9tUGlja2VyKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdOb3RlIFBhdGgnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoZSBwYXRoIGFuZCBmaWxlbmFtZSBvZiB0aGUgbm90ZSB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0cyB0byBiZSB1c2VkLiBFeGVtcGxlIDogXCJGb2xkZXIvTm90ZVwiLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHRoZSBwYXRoIHRvIHlvdXIgbm90ZScpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGVQYXRoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90ZVBhdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlNob3cgd2FybmluZ1wiKVxuICAgICAgICAgICAgLnNldERlc2MoJ0Rpc3BsYXkgdGhlIHdhcm5pbmdzIG9mIG5vdGVzIGFuZCBsaXN0cywgaWYgYW55LiBXYXJuaW5ncyBmb3IgbWFjcm8gZGVwdGggbGltaXQgcmVhY2hlZCBhcmUgYWx3YXlzIGRpc3BsYXllZC4nKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNob3dXYXJuaW5nKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNob3dXYXJuaW5nID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiTWFjcm8gZGVwdGggbGltaXRcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiTWFjcm8gcmVjdXJzaW9uIGxpbWl0OiBob3cgbWFueSBuZXN0ZWQgbWFjcm8gY2FsbHMgYXJlIGFsbG93ZWQuIFplcm8gcHJldmVudHMgbmVzdGVkIG1hY3JvcyBmcm9tIGJlaW5nIHJlc29sdmVkLlwiKVxuICAgICAgICAgICAgLmFkZFNsaWRlcigoc2xpZGVyKSA9PlxuICAgICAgICAgICAgICAgIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4TWFjcm9EZXB0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRMaW1pdHMoMCwgMTAsIDEpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4TWFjcm9EZXB0aCA9IHZhbHVlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTGlzdCBwcmVmaXggZm9yIG5vdGlmaWNhdGlvbicpXG4gICAgICAgICAgICAuc2V0RGVzYygnSWYgYSBsaXN0IGhlYWRpbmcgYmVnaW4gd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlLCB0aGUgcGlja2VkIGl0ZW0gaXMgbm90IGluc2VydGVkLCBidXQgbm90aWZpZWQuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIgcHJlZml4IHZhbHVlJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90aWNlUHJlZml4KVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90aWNlUHJlZml4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgfVxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFB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
